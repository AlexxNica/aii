####################################################################
#
#  README (SDW - 30/06/2007)
#
# sl_ks_begrid.conf is a modified version of the sl_ks.conf 
# (based on CVS 1.14) that fixes some issues when using a 
# non-standard setup. Provides working ks files for
# - sindes
# - non-dhcp/pxeboot installation (eg manual xen start)
# - rpm & httpproxy
# - default removal of autoupdate services
#
# This example is provided so other people can reuse some of it
# when facing similar problems. Feel free to contact us through the 
# quattor mailing list for details or an updated version.
#
####################################################################
#
# sl_ks.conf	KickStart configuration file for ScientificLinux 3/4 
# with integrated SINDES support
#
# This is a KickStart configuration file template used by the
# aii-osinstall utility of the Automated Installation Infrastructure,
# quattor toolkit (quattor.org)
# 
# Enrico Ferro \<enrico.ferro@pd.infn.it\>
# Rafael Garcia Leiva \<angel.leiva@uam.es\>
# Cesar Lobo \<cesar.lobo@uam.es\>
# Michel Jouvin \<jouvin@lal.in2p3.fr\>
# Jorge Izquierdo \<jorge.izquierdo@uam.es\>
# Luis Fernando Muñoz Mejías \<mejias@delta.ft.uam.es\>	
# Ronald Starink \<ronalds@nikhef.nl\>
#
# Copyright (c) 2005 EU DataGrid.
# For license conditions see http://www.eu-datagrid.org/license.html
#
# KickStart file generated at <DATE>
#

install		# Install (do not upgrade)
text		# Use text mode
reboot		# Reboot at the end
<IF: /system/aii/osinstall/options/xwindows>
	</system/aii/osinstall/options/xwindows>
<ELSE:>
	# Do not configure XWindow (default)
	## keep it like this. gives problems with sl50
	skipx           
<ENDIF>

# System language
lang        </system/aii/osinstall/options/lang>
langsupport --default </system/aii/osinstall/options/langsupp>

# Keyboard and mouse
keyboard    </system/aii/osinstall/options/keyboard>
mouse       </system/aii/osinstall/options/mouse>

# Timezone
timezone    --utc </system/aii/osinstall/options/timezone>

# Root password
rootpw      --iscrypted </system/aii/osinstall/options/rootpw>

# System bootloader configuration
bootloader  --location=</system/aii/osinstall/options/bootloader_location>

<IF: /system/aii/osinstall/options/selinux>
    # SE linux is only supported in SL4
    selinux </system/aii/osinstall/options/selinux>
<ENDIF>

# Installation type
</system/aii/osinstall/options/installtype>

# Clear the Master Boot Record?
<IF: /system/aii/osinstall/options/clearmbr>
	zerombr     yes
<ENDIF>

# Partitioning is made during %pre phase. This includes
# clearing (or not) the partition table.
<SET: $path=/system/filesystems/disks>

<FOREACH: $disk <$path> >
	<FOREACH: $part <$path>/<$disk> >
		<IF: <$path>/<$disk>/<$part>/format >
			<SET: $format =>
		<ELSE:>
			<SET: $format = '--noformat'>
		<ENDIF>
		<IF: <$path>/<$disk>/<$part>/ksopt>
			<SET: $ksopt = < <$path>/<$disk>/<$part>/ksopt> >
		<ELSE:>
			<SET: $ksopt=>
		<ENDIF>
		<SET: $mountp = <$path>/<$disk>/<$part>/mountpoint>
		<SET: $fstype = <$path>/<$disk>/<$part>/type >
		<SET: $mount = <$path>/<$disk>/<$part>/mount>
		<IF: <$mount> >
			part < <$mountp> > --fstype < <$fstype> > --onpart <SHELL: echo -n <UNESCAPE: <$part> > | sed 's/0\+\([0-9]\+\)/\1/g' > <$format> <$ksopt>
		<ENDIF>
		<FOREACH: $log_part <$path>/<$disk>/<$part>/logical_partitions>
			<SET: $lpath = <$path>/<$disk>/<$part>/logical_partitions/<$log_part> >
			<SET: $mount = <$lpath>/mount>
			<SET: $fstype = <$lpath>/type>
			<SET: $mountp = <$lpath>/mountpoint>
			<IF: <$lpath>/format >
				<SET: $format =>
			<ELSE:>
				<SET: $format = '--noformat'>
			<ENDIF>
			<IF: <$lpath>/ksopt>
				<SET: $ksopt = < <$lpath>/ksopt > >
			<ELSE:>
				<	SET: $ksopt =>
			<ENDIF>
			<IF: <$mount> >
				part < <$mountp> > --fstype < <$fstype> > --onpart <SHELL: echo -n <UNESCAPE: <$log_part> > |sed 's/0\+\([0-9]\+\)/\1/g' > <$format> <$ksopt>
			<ENDIF>
		<ENDFOR>
	<ENDFOR>
<ENDFOR>

# LVM volume creation
# Authors:
# Enrico Ferro \<enrico.ferro@pd.infn.it\>
# Rafael Garcia Leiva \<angel.leiva@uam.es\>
# Cesar Lobo \<cesar.lobo@uam.es\>
# Michel Jouvin \<jouvin@lal.in2p3.fr\>
# Luis Fernando Muñoz Mejías \<mejias@delta.ft.uam.es\>
<FOREACH: $disk <$path>>
	<FOREACH: $part <$path>/<$disk>>
		<SET: $fstype = <$path>/<$disk>/<$part>/type >
		<IF: <$fstype> = "lvm">
			<SET: $vgname = < <$path>/<$disk>/<$part>/label> >
			<SET: $pvname = <UNESCAPE: pv.<$disk> > >
			<SET: $size   = < <$path>/<$disk>/<$part>/size> >
			<SET: $ksopt  = >
			<IF: <$path>/<$disk>/<$part>/ksopt>
				<SET: $ksopt = < <$path>/<$disk>/<$part>/ksopt> >
			<ENDIF>
			<IF: <$path>/<$disk>/<$part>/grow >
				<SET: $grow = '--grow'>
			<ELSE:>
				<SET: $grow =>
			<ENDIF>
			part <$pvname> --ondisk <UNESCAPE: <$disk>>  --size <$size> <$ksopt> <$grow>
			volgroup <$vgname> <$pvname>
			<FOREACH: $log_part <$path>/<$disk>/<$part>/logical_partitions>
				<SET: $mountp = < <$path>/<$disk>/<$part>/logical_partitions/<$log_part>/mountpoint> >
				<SET: $size   = <<$path>/<$disk>/<$part>/logical_partitions/<$log_part>/size>>
				<SET: $fstype = <<$path>/<$disk>/<$part>/logical_partitions/<$log_part>/type>>
				<IF: <$path>/<$disk>/<$part>/logical_partitions/<$log_part>/grow>
					<SET: $grow = '--grow'>
				<ELSE:>
					<SET: $grow =>
				<ENDIF>
				<SET: $ksopt  = >
				<IF: <$path>/<$disk>/<$part>/logical_partitions/<$log_part>/ksopt>
					<SET: $ksopt = < <$path>/<$disk>/<$part>/logical_partitions/<$log_part>/ksopt> >
				<ENDIF>
				logvol <$mountp> --size <$size> --fstype <$fstype> --name <$log_part> --vgname  <$vgname> <$ksopt> <$grow>
			<ENDFOR>
		<ENDIF>
	<ENDFOR>
<ENDFOR>

# Network configuration
<FOREACH: $device /system/network/interfaces>
	<IF: /system/network/interfaces/<$device>/ip >
		network     --bootproto static  --ip </system/network/interfaces/<$device>/ip>  --netmask </system/network/interfaces/<$device>/netmask>  --gateway </system/network/default_gateway>  --nameserver </system/network/nameserver/0> --device <$device>  --hostname </system/network/hostname>.</system/network/domainname>
	<ENDIF>
<ENDFOR>

# Authorization
auth        </system/aii/osinstall/options/auth>

# Firewall configuration
firewall    </system/aii/osinstall/options/firewall>

# Packages groups/list
%packages --resolvedeps --ignoremissing

</system/aii/osinstall/options/packages>

%pre

#########################################################
#
# 09/08/2005
#
# Preinstallation fdisk partitioning
#
# AUTHOR: Cesar Lobo (cesar.lobo@uam.es)
# 19/01/2006
#
# Errata correction: size on logical partitions 
#
# AUTHOR: Jorge Izquierdo (jorge.izquierdo@uam.es)
#
# 15/01/2007
# Rewritten
# AUTHOR: Luis Fernando Muñoz Mejías (mejias@delta.ft.uam.es)
#########################################################

# Returns the device name (e.g: hda) from a partition name (e.g: hda3)
get_dev_from_part () {
	if expr match ${1} 'ciss/*' \> /dev/null
	then
		echo ${1}|sed 's/\(.*[a-z]\)p[0-9]\+$/\1/'
	else
		echo ${1}|sed 's/\(.*[a-z]\)[0-9]\+$/\1/'
	fi
}

# Returns the partition number (e.g: 1) from a partition name (e.g: sdc1)
get_partnum_from_part () {
	echo ${1}|sed 's/.*[a-z]\([0-9]\+\)$/\1/'
}

# Creates a new partition of the specified size and type.
# Arguments: $1: block device name
# $2: partition size
# $3: partition type (p if primary, e if extended, l if logical)
create_partition () {

	local disk=`get_dev_from_part ${1}`
	local part=`get_partnum_from_part ${1}`

	cat \<\<EOF | fdisk /dev/${disk}
n
$3
${part}

$2
w
EOF
}

# Deletes an existing partition. To be used when "preserve" tag is
# false.
# Arguments: $1: block device name (partition name)
delete_partition() {
	local disk=`get_dev_from_part ${1}`
	local part=`get_partnum_from_part ${1}`
	
	cat \<\<EOF |fdisk /dev/${disk}
d
${part}
w
EOF
}

# Clears the partition table on a device.
# Arguments: $1: device name
clear_partitions () {


   cat \<\<EOF| fdisk /dev/${1}
o
w
EOF
}

# Sets the ID of a given partition.
# Arguments: $1: block device name
# $2: type attribute of the profile
set_partition_type () {

	local disk=`get_dev_from_part ${1}`
	local part=`get_partnum_from_part ${1}`
	local hex
	
	case $2 in
	"extended")
		hex=5
		;;
	"raid")
		hex=fd
		;;
	"swap")
		hex=82
		;;
	"lvm")
		hex=8e
		;;
	"ntfs")
		hex=7
		;;
	"vfat")
		hex=b
		;;
	"fat16")
		hex=6
		;;
	"w95ext")
		hex=f
		;;
	*)
		hex=83
		;;
	esac
	
	# Special case: the disk holds only one partition
	if [ `grep ${disk} /proc/partitions|wc -l` -le 2 ]
	then
		cat \<\< EOF |fdisk /dev/${disk}
t
${hex}
w
EOF
	else	
		cat \<\< EOF| fdisk /dev/${disk}
t
${part}
${hex}
w
EOF
	fi
}

# Returns a true value if the block device received as an argument exists.
partition_exists () {
	grep ${1} /proc/partitions \> /dev/null
}

<FOREACH: $dev <$path> >
	<SET: $disk = <UNESCAPE: <$dev> > >
	
	<IF: /system/aii/osinstall/options/clearpart>
		clear_partitions <$disk>
	<ENDIF>
	
	# Erase all un-preserved partitions
	<FOREACH: $part <$path>/<$dev> >
		<SET: $preserve = <$path>/<$dev>/<$part>/preserve>
		<IF: <$preserve> >
		<ELSE: >
			delete_partition <SHELL: echo -n <UNESCAPE: <$part> > | sed 's/0\+\([0-9]\+\)/\1/g' >
			
		<ENDIF>
		<FOREACH: $lpart <$path>/<$dev>/<$part>/logical_partitions>
			<SET: $preserve = <$path>/<$dev>/<$part>/logical_partitions/<$lpart>/preserve>
			<IF: <$preserve> >
			<ELSE:>
				delete_partition <SHELL: echo -n <UNESCAPE: <$lpart> > | sed 's/0\+\([0-9]\+\)/\1/g' >
				
			<ENDIF>
		<ENDFOR>
	<ENDFOR>
	
	# Create all primary and/or extended partitions
	<DSSTFOREACH: $part <$path>/<$dev> >
		<SET: $type = <$path>/<$dev>/<$part>/type>
		<IF: <$path>/<$dev>/<$part>/grow >
			size=''
		<ELSE:>
			size=+< <$path>/<$dev>/<$part>/size>M
		<ENDIF>
		<IF: <$path>/<$dev>/<$part>/type = "extended">
			ptype=e
		<ELSE:>
			ptype=p
		<ENDIF>
		<IF: <$path>/<$dev>/<$part>/preserve>
			# Request to preserve the partition. Create IFF it doesn't exist		
			if ! partition_exists <SHELL: echo -n <UNESCAPE: <$part> > | sed 's/0\+\([0-9]\+\)/\1/g' >

			  then
		<ENDIF>
				create_partition <SHELL: echo -n <UNESCAPE: <$part> > | sed 's/0\+\([0-9]\+\)/\1/g' > \
				    "$size" $ptype
		<IF: <$path>/<$dev>/<$part>/preserve>
				mkfs.< <$type> > /dev/<$part>
			fi
		<ENDIF>
		# Create all logical partitions
		<DSSTFOREACH: $lpart <$path>/<$dev>/<$part>/logical_partitions >
			<SET: $lpath = <$path>/<$dev>/<$part>/logical_partitions/<$lpart> >
			<SET: $type = <$lpath>/type>
			<IF: <$lpath>/grow >
				size=''
			<ELSE:>
				size=+< <$lpath>/size>M
			<ENDIF>
			<IF: <$lpath>/preserve >
				if ! partition_exists <SHELL: echo -n <UNESCAPE: <$lpart> > | sed 's/0\+\([0-9]\+\)/\1/g' >

				    then
			<ENDIF>
					create_partition <SHELL: echo -n <UNESCAPE: <$lpart> > | sed 's/0\+\([0-9]\+\)/\1/g' > \
					    "$size" l
			<IF: <$lpath>/preserve >
					mkfs.< <$type> > /dev/<$lpart>
				fi
			<ENDIF>
		<ENDDSSTFOR>		
	<ENDDSSTFOR>
	# Add de appropiate partition ID
	<DSSTFOREACH: $part <$path>/<$dev> >
		<SET: $type = <$path>/<$dev>/<$part>/type  >
		set_partition_type <SHELL: echo -n <UNESCAPE: <$part> >| sed 's/0\+\([0-9]\+\)/\1/g' > \
		    < <$type> >
		<IF: <$type> = "extended" >
			<DSSTFOREACH: $lpart <$path>/<$dev>/<$part>/logical_partitions > 
				<SET: $type = <$path>/<$dev>/<$part>/logical_partitions/<$lpart>/type>
				set_partition_type <SHELL: echo -n  <UNESCAPE: <$lpart> > | sed 's/0\+\([0-9]\+\)/\1/g' > \
				    < <$type> >
			<ENDDSSTFOR>
		<ENDIF>
	<ENDDSSTFOR>
	# REMOVE all LVM partitions, as they will be handled elsewere
	<DSSTFOREACH: $part <$path>/<$dev> >
		<SET: $type = <$path>/<$dev>/<$part>/type >
		<IF: <$type> = "lvm" >
			delete_partition <$part>
		<ENDIF>
	<ENDDSSTFOR>
<ENDFOR>

##
## Large partition support
## 
## remove the affected partitions above by hand 
## use following example to construct correct partitioning
##
## tested with parted 1.8.1
## use the y in parted mklabel to answer the Warning message
## like parted $dev mklabel y gpt
## -s option does not work
##
## dev=/dev/sdb
## ## using dd first removes the warning
## dd if=/dev/zero of=$dev bs=1M count=1
## ## make the label before determining the size
## /usr/sbin/parted $dev mklabel gpt
## ## get the size in MB
## end_in_MB=`/usr/sbin/parted $dev unit MB print |sed -nr '{ s#Disk[[:space:]]+/dev/[a-z]+:[[:space:]]([0-9]+)MB#\1#p }'`
## ## make the partition
## /usr/sbin/parted $dev mkpart xfs 1 $end_in_MB
##

##
## XFS partition support
##
## sunit and swidth parameters are expressed in 512byte blocks
## sunit is the stripe size 
## swidth is the stripe width, typically the number of data disks times the stripe unit 
## eg. a 14 disk RAID6 config with stripe size of 64kB (so there are 12 data disks)
## sunit=128 and data_disks=12  (swidth=$sunit*$data_disks=1536)
##
##
## ## unit size in 512 byte blocks
## sunit=128
## ## number of data disks
## data_disks=12
## ## device to format
## dev=/dev/sdb1
## ## calculate swidth
## swidth=$(($sunit*$data_disks))
## ## make the partition
## ## make sure the --noformat option is enabled for this device in the part section above
## /usr/sbin/mkfs.xfs -d sunit=$sunit,swidth=$swidth $dev


<IF: /system/aii/osinstall/options/pre_install_script>
	<SET: $script_url=</system/aii/osinstall/options/pre_install_script>>
	oldcwd=`pwd`
	cd /root
	wget <$script_url>
	script=./`basename <$script_url>`
	chmod +x $script
	$script
	cd $oldpwd
<ENDIF>
#
# Post installation script
#

%post

#
# create /etc/rc.d/init.d/ks-post-reboot and
# modify the startup sequence to run it at the first reboot
#

cat \<\<End_Of_Post_Reboot \>/etc/rc.d/init.d/ks-post-reboot
#!/bin/sh -x
#-----------------------------------------------------------------------------
#
# script to run at the first reboot
#
#-----------------------------------------------------------------------------

# Function to be called if failure. It sends SPMA and ncm-components'
# logs to </system/rootmail> .
fail () {
	echo "Quattor installation failed: \$1"
	
	(cat \<\< EOF
From: root@`hostname`
To: </system/rootmail>
Subject: Quattor instalation failed: \$1

EOF
	cat /root/ks-post-install.log
	echo ------------------------------------------------------------
	ls -tr /var/log/ncm/| \
		xargs tail /var/log/spma.log
	echo .) | sendmail -t
	exit -1
}

# Function to be called if success. It just tells
# the node was correctly installed, as requested in 
# bug #23003
success () {
	cat \<\< EOF | sendmail -t
From: root@`hostname`
To: </system/rootmail>
Subject: Quattor instalation on `hostname` succeeded!

Computer `hostname` was succesfully installed
.
EOF
}

# ensure that the logfile does not exist.

[ -e /root/ks-post-install.log ] && \\
fail "last installation went wrong, aborting - see logfile "

# redirect the output to the log file
exec \> /root/ks-post-install.log 2\>&1

# show the output on the seventh console
tail -f /root/ks-post-install.log \> /dev/tty7 &


###########################################################################
#
# Install the Quattor client
#
###########################################################################

# Note: The following block (between SPMA-start and SPMA-end) is specific
#       to clients running SPMA. If you want to use APT/YUM instead
#       for managing your clients, you must *remove* the complete block,
#       and replace it with:
#          1. adding the Quattor APT repository to the
#             APT/Yum configuration
#          2. run:
#              'apt-get update && apt-get install quattor-client' (for APT)
#              'yum install quattor-client' (for YUM)
#
#       See the APT/Yum chapter of the Quattor installation guide for
#       details on how to do this.

#--------------------------------------------------------------------------
# SPMA-start
#--------------------------------------------------------------------------
#
# install CCM, NCM, SPMA and friends
#


<SET: $proxy_opts = >
<IF: /software/components/spma/proxy>
	<LIF: </software/components/spma/proxy> = yes>
		<IF: /software/components/spma/proxyhost>
			<SET: $proxy_opts = --httpproxy </software/components/spma/proxyhost>>
			<IF: /software/components/spma/proxyport>
				<SET: $proxy_opts = <$proxy_opts> --httpport </software/components/spma/proxyport>>
			<ENDIF>
		<ENDIF>
	<ENDLIF>
<ENDIF>

RPM_PROXY="<$proxy_opts>"

install_rpm () {

  fil=\${1##*/}
  pack=\${fil%.rpm}
	
  ## checl if already installed
  /bin/rpm -qi \$pack 

  if [ "\$?" -eq "0" ]
  then
    ## already installed
    echo "Package \$pack already installed. Skippng."
  else
   /bin/rpm -Uvh \$RPM_PROXY  \\
  	\$1 \\
  	|| fail "rpm failed (\$?)"
  fi

}

for RPM_URL in <PACKAGEPATH:perl-Compress-Zlib>/<PACKAGE:perl-Compress-Zlib> <PACKAGEPATH:perl-LC>/<PACKAGE:perl-LC> <PACKAGEPATH:perl-AppConfig-caf>/<PACKAGE:perl-AppConfig-caf> <PACKAGEPATH:perl-Proc-ProcessTable>/<PACKAGE:perl-Proc-ProcessTable> <PACKAGEPATH:perl-CAF>/<PACKAGE:perl-CAF>
do 
  install_rpm \$RPM_URL  
done
    
# Configuration Cache Manager
install_rpm <PACKAGEPATH:ccm>/<PACKAGE:ccm>

# Node Configuration Deployer
for RPM_URL in <PACKAGEPATH:ncm-template>/<PACKAGE:ncm-template> <PACKAGEPATH:ncm-ncd>/<PACKAGE:ncm-ncd> <PACKAGEPATH:ncm-query>/<PACKAGE:ncm-query>
do 
  install_rpm \$RPM_URL
done

# Software Package Management Agent
for RPM_URL in <PACKAGEPATH:rpmt-py>/<PACKAGE:rpmt-py> <PACKAGEPATH:spma>/<PACKAGE:spma> <PACKAGEPATH:ncm-spma>/<PACKAGE:ncm-spma>
do 
  install_rpm \$RPM_URL 
done

# CDP listend daemon

install_rpm <PACKAGEPATH:cdp-listend>/<PACKAGE:cdp-listend>

# Configuration Dispatch Daemon

install_rpm <PACKAGEPATH:ncm-cdispd>/<PACKAGE:ncm-cdispd>	

#--------------------------------------------------------------------------
# SPMA-end
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
# SINDES-begin
#--------------------------------------------------------------------------
<IF: /software/components/sindes/http_sel>

## fix the date on the nodes
## otherwise possible errors like
## Preparing...                ##################################################
## SINDES-client               ##################################################
## make: Warning: File 'Makefile.crt' has modification time 1.7e+08 s in the futureMakefile.crt    ... Skipped
## make: warning:  Clock skew detected.  Your build may be incomplete.


### needed rpms, curl is handled through /software/components/aii/osinstall/options/packages for dependency problems
for RPM_URL in <PACKAGEPATH:SINDES-client>/<PACKAGE:SINDES-client> <PACKAGEPATH:</software/components/sindes/ca_cert_rpm>>/<PACKAGE:</software/components/sindes/ca_cert_rpm>>
do 
  install_rpm \$RPM_URL
done

## it's necessary that the connection between client and CA is direct. therefore, extra routes might be necessary
<IF: /software/components/sindes/aii_route>
</software/components/sindes/aii_route>
<ENDIF>

cat \> /etc/sindes/get-cert.conf \<\<EOF

# Https server
HTTP_SEL="</software/components/sindes/http_sel>"
HTTPS_SERVER="</software/components/sindes/https_server>"

RENEW_CERT_PORT=</software/components/sindes/renew_cert_port>
NEW_CERT_PORT=</software/components/sindes/new_cert_port>

#domain name, to be removed from the hostname if it's a FQDN
DOMAIN_NAME="</software/components/sindes/domain_name>"

#login/passwd for first certificate request.
# /!\ beware of chicken & egg problem here.
USER=
PASSWD=
USE_PASSWD=0


# Organisation and Unit:
CRT_O="</software/components/sindes/crt_o>"
CRT_OU="</software/components/sindes/crt_ou>"

# RSA or DSA ?
USE_RSA=1
KEY_LENGTH=1024

# usefull for program that needs to key+crt in a single pem file, eg curl
CREATE_PEM=1

URL_NEW_SUFFIX="/newcert/"
URL_RENEW_SUFFIX="/renewcert/"

OPENSSL=openssl
CURL=curl
##CA_CERT_FILE="</software/components/sindes/cert_dir>/</software/components/sindes/ca_cert>"
CA_CERT_DIR="</software/components/sindes/cert_dir>"

# if USE_TMP_FILES != "" then 5 following var will
TMP_DIR=/var/tmp/get-crt-XXXXXX

CRT_FILE="client.crt"
PEM_FILE="client_test.pem"
TMP_CONFIG="client.ssl.config"
KEY_FILE="client.key"
CSR_FILE="client.csr"

# do we install the resulting certificate?
# if so, where? (=-1 indicates we don't want to install this one)
INSTALL_DIR=</software/components/sindes/cert_dir>
CLIENT_CERTIFICATE_PEM=\\\$INSTALL_DIR/</software/components/sindes/client_cert>
CLIENT_PRIVATE_KEY_PEM=\\\$INSTALL_DIR/</software/components/sindes/client_key>
CLIENT_CERTIFICATE_KEY_PEM=\\\$INSTALL_DIR/</software/components/sindes/client_cert_key>

# this one should not be set as ca is _constant_, it should come from an RPM
CA_CERTIFICATE_PEM=-1

# if true, will try to overwrite already existing files /!\ dangerous!
INSTALL_OVERWRITE=0

EOF


### get certificate
sindes-get-certificate
<ENDIF>
#--------------------------------------------------------------------------
# SINDES-end
#--------------------------------------------------------------------------


###########################################################################
#
# Configure the Quattor client
#
###########################################################################


# Create the initial CCM configuration file

cat \<\<End_Of_CCM_Conf \> /etc/ccm.conf
profile		</system/aii/osinstall/options/node_profile>
<IF: /software/components/ccm/key_file>
	<IF: /software/components/ccm/cert_file>
		key_file        </software/components/ccm/key_file>
		cert_file       </software/components/ccm/cert_file>
	<ENDIF>
<ENDIF>
<IF: /software/components/ccm/ca_file>
	ca_file         </software/components/ccm/ca_file>
<ENDIF>
<IF: /software/components/ccm/world_readable>
	world_readable  </software/components/ccm/world_readable>
<ENDIF>

End_Of_CCM_Conf

# initialise the CCM

/usr/sbin/ccm-initialise \\
    || fail "CCM intialization failed (\$?)"

# Download my configuration profile

/usr/sbin/ccm-fetch || fail "ccm-fetch failed (\$?)"

# Upgrade the system

/usr/sbin/ncm-ncd --configure spma \\
    || fail "/usr/sbin/ncm-ncd --configure spma failed"
/usr/bin/spma --userpkgs=no --userprio=no \\
    || fail "/usr/bin/spma failed"
/usr/sbin/ncm-ncd --configure --all

<IF: /system/aii/osinstall/options/post_reboot_script>
	#
	# execute post-reboot user script
	#
	<SET: $script_url=</system/aii/osinstall/options/post_reboot_script>>
	pushd /root
	wget <$script_url>
	script=./`basename <$script_url>`
	chmod +x \$script
	\$script
	popd
<ENDIF>

<IF: /system/aii/osinstall/options/email_success = "true">
	success
<ENDIF>
#
# cleanup so that we're not called anymore
#
rm -f /etc/rc.d/rc3.d/S86ks-post-reboot

#
# reboot once more then,
# quattor will take control of the node
#
shutdown -r now

#
exit 0

# end of post reboot script
#-----------------------------------------------------------------------------
End_Of_Post_Reboot


#
# At this point, the Kernel must be upgraded (see Savannah #5007)
#

<LFOREACH: $pkg kernel kernel-smp kernel-xenU kmod-xfs>
  <LFOREACH: $k <PACKAGELIST: <$pkg>>>
        <SET: $rpmpath = <PACKAGEPATH: <$k> >>
    /bin/rpm -iv --force <$rpmpath>/<$k>
  <ENDLFOR>
<ENDLFOR>



<SET: $ksdevice = </system/aii/nbp/options/ksdevice>>
<SET: $net_driverrpms_path = /hardware/cards/nic/<$ksdevice>/driverrpms>
<IF: <$net_driverrpms_path>>

# Install Network driver if not in standard distribution
# driverrpm property is interpreted as space separated list (allow smp and non smp install)
# Be sure to rebuild module dependencies for all kernels installed
# (kernel during installation is probably not the production one, e.g. non smp).
# This sometimes not properly done in the RPM (e.g. improper path for depmod).

net_driver_log="/root/net-driver-install.log"

net_driver_failed () {
    error_msg="Failed to install network driver for <$ksdevice> ($1). See log file $net_driver_log"
    /bin/echo "$error_msg"
    /bin/cat $net_driver_log
    /bin/cat $net_driver_log | /bin/mail -s "Quattor installation failed ($error_msg)" </system/rootmail> \>\> $net_driver_log 2\>&1
    exit -1
}

<FOREACH: $net_driver_num <$net_driverrpms_path>>
	<SET: $net_driver_rpm = <<$net_driverrpms_path>/<$net_driver_num>>>
	net_driver_path="<PACKAGEPATH:<$net_driver_rpm>>/<PACKAGE:<$net_driver_rpm>>"
	/bin/echo "Installing <$net_driver_rpm> ($net_driver_path)..." \>\> $net_driver_log 2\>&1
	/bin/rpm -Uvh $net_driver_path  \>\> $net_driver_log 2\>&1
	if [ $? -ne 0 ]
	then
    		net_driver_failed "rpm <$net_driver_rpm> failure"
	fi
<ENDFOR>

kernels=`ls /lib/modules`
for kernel in $kernels
do
    /bin/echo "Rebuilding module dependencies for kernel $kernel..." \>\> $net_driver_log 2\>&1
    /sbin/depmod $kernel \>\> $net_driver_log 2\>&1
    if [ $? -ne 0 ]
    then
        net_driver_failed "depmod failure"
    fi
done

<ENDIF>

<IF: /system/aii/osinstall/options/post_install_script>
#
# execute post-install user script
#
	<SET: $script_url=</system/aii/osinstall/options/post_install_script>>
	pushd /root
	wget <$script_url>
	script=./`basename <$script_url>`
	chmod +x $script
	$script
	popd
<ENDIF>

#
# hook the post reboot script into rc.d
#
chmod +x /etc/rc.d/init.d/ks-post-reboot
ln -s /etc/rc.d/init.d/ks-post-reboot /etc/rc.d/rc3.d/S86ks-post-reboot

#
# disable services (if they exist)
#
for SERVICE in yum-autoupdate yum apt
do
  /sbin/chkconfig --list $SERVICE 
  if [ $? -eq 0 ]
  then
    /sbin/chkconfig --del $SERVICE
  fi
done

## set the correct kernel to boot with
eval `/sbin/grubby --info ALL|grep </system/kernel/version>`
/sbin/grubby --set-default $kernel

#
# Switch off pxeboot
#

wget -q --output-document=- </system/aii/osinstall/options/ackurl>
