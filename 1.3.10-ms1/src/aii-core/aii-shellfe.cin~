#!@PERL_EXECUTABLE@ -w
################################################################################
# This is '@SELF@', a @NAME@'s file
################################################################################
#
# VERSION:    @VERSION@, @DATE@
# AUTHOR:     @AUTHOR@
# MAINTAINER: @MAINTAINER@
# LICENSE:    @LICENSE@
#
################################################################################
# Coding style: emulate <TAB> characters with 4 spaces, thanks!
################################################################################
#
# @SELF@      AII Local Management Shell Frontend
# 
################################################################################

=pod

=head1 NAME

aii-shellfe - AII local management utility

=head1 SYNOPSIS

 aii-shellfe --cdburl URL [options]
 
                       <--boot <hostname|regexp>      |
                        --bootlist <filename>         |
                        --configure <hostname|regexp> |
                        --configurelist <filename>    |
                        --install <hostname|regexp>   |
                        --installlist <filename>      |
                        --notify                      |
                        --remove <hostname|regexp>    |
                        --removelist <filename> >     |
                        --removeall                   |
                        --rescue <hostname|regexp>    |
                        --rescuelist <filename>       |
                        --status <hostname|regexp>    |
                        --statuslist <filename> >

=head1 DESCRIPTION

=over 4

aii-shellfe is the user frontend for the quattor Automated Installation
Infrastructure. aii-shellfe is used to automatically manage
DHCP, the Network Bootstrap Program (NBP), and the OS installer.
aii-shellfe is a wrapper or the programs aii-dhcp, aii-nbp
and aii-osinstall.

aii-shellfe can be used locally, or remotely called with aii-installfe.
aii-shellfe can be called by the CDB notification handler for
the automatic synchronisation with CDB as well.

Input data can be specified via the command line (for just one host)
or via a text file (for more than one host). Perl regular expressions
(see EXAMPLES) instead of hostnames are supported (only in case
of command line options).

Note that you have to configure (command --configure) the client nodes
before to mark them for the installation or to boot from local disk.

aii-shellfe needs the URL for the location of the CDB. Instead of CDB,
a plain http(s) server may be used to fetch the profiles. It is 
recommended to store this parameter in the aii-shellfe.conf 
configuration file.

=back

=head1 COMMANDS

=over 4

=item --boot <hostname|regexp>

Select boot from local disk for <hostname> or for all hostnames
that match the Perl regular expression <regexp>

=item --bootlist <filename>

Select boot from local disk for hosts listed on <filename>. Each line
should contain one host name. Lines starting with a # are comment lines.

=item --install <hostname|regexp>

Select to install <hostname> or all hostnames
that match the Perl regular expression <regexp>

=item --installlist <filename>

Select to install the hosts listed in <filename>. Each line
should contain one host name. Lines starting with a # are comment lines.

=item --configure <hostname|regexp>

Configure <hostname> or all hostnames that match the Perl regular
expression <regexp>

=item --configurelist <filename>

Configure hosts listed in <filename>. Each line
should contain one host name. Lines starting with a # are comment lines.

=item --notify

aii-shellfe should be executed with this parameter by CDB notification
client, i.e. whenever the content of CDB changes.

=item --remove <hostname|regexp>

Remove the configuration for <hostname> or all hostnames that match the
Perl regular expression <regexp>

=item --removelist <filename>

Remove configurations for hosts listed in <filename>. Each line
should contain one host name. Lines starting with a # are comment lines.

=item --removeall

Remove configurations for *ALL* hosts configured. Useful only in case
of problems/test (note that DHCP configuration is not affected by
this command).

=item --status <hostname|regexp>

Report the boot status (boot from local disk/install) for <hostname> or
for all hostnames that match the Perl regular expression <regexp>

=item --statuslist <filename>

Report the boot status (boot from local disk/install) for hosts listed
in <filename>. Each line should contain one host name. Lines starting 
with a # are comment lines.

=item --rescue <hostname|regexp>

Use the Rescue image (LOCATION) to boot <hostname> or all hostnames 
that match the Perl regular expression <regexp>.

=item --rescuelist <filename>

Use the Rescue image (LOCATION) to boot the hosts listed in <filename>.
Each line should contain one host name. Lines starting with a # are 
comment lines.


=back

=head1 OPTIONS

=over 4

=item --nodhcp

Do not update DHCP configuration.

=item --nonbp

Do not update NBP configuration.

=item --noosinstall

Do not update OS installer configuration.

=item --localnclcache

Local cache to store list of last profiles + their timestamp
from CDB synchronisation subsystem.

=item --cdburl <url>

URL for CDB location

=back

=head2 Other Options

=over

=item --help

Displays a help message with all options and default settings.

=item --version

Displays program version information.

=item --verbose

Print verbose details on operations.

=item --debug <1..5>

Set the debugging level to <1..5>.

=item --cfgfile <path>

Use as configuration file <path> instead of the default
configuration file @QTTR_ETC@/aii-shellfe.conf.

=item --logfile <file>

Store and append log messages in <file>.

=item --noaction

Compute and show the operations, but do not execute them.

=item --cert_file <file>

Absolute file name for certificate file to use with HTTPS.

=item --key_file <file>

Absolute file name for key file to use with HTTPS.

=item --ca_file <file>

File containing a bundle of trusted CA certificates for use with HTTPS.

=item --ca_dir <dir>

Directory containing trusted CA certificates for use with HTTPS.
Hash symlinks are needed.

=item --use_fqdn

When retrieving profiles, keep the fully qualified domain name in
the name of the profile (if specified).

=item --profile_prefix <prefix>

Set the prefix for the profile names that AII will fetch from the CDB. 
The default is 'profile_'. To disable the usage of a prefix, 
set profile_prefix to an empty string in the configuration file 
@QTTR_ETC@/aii-shellfe.conf.

=back

=head1 CONFIGURATION FILE

=over 4

Default values of command lines options can be specified in the file
@QTTR_ETC@/aii-shellfe.conf using syntax:

 <option> = <value>

=back

=head1 EXAMPLES

=over 4

E.g. to get the status of all nodes:

 aii-shellfe --status .+

To prepare configuration files for grid001, grid002, grid005:

 aii-shellfe --configure grid00[125]

To set as "to be installed" grid001 and grid002:

 aii-shellfe --install grid00[12]

=back


=head1 RETURN

=over 4

On success, aii-shellfe returns 0. Fatal errors are indicated by return value 1. 
When non-fatal errors occur, aii-shellfe returns 16.

=back


=head1 AUTHORS

Enrico Ferro <enrico.ferro@pd.infn.it>

Rafael A. Garcia Leiva <angel.leiva@uam.es>

=cut

#
# Standard Common Application Framework beginning sequence
#

#
# Beginning sequence for EDG initialization
#
BEGIN {

    # use perl libs in @QTTR_PERLLIB@
    unshift(@INC, '@QTTR_PERLLIB@');
    unshift(@INC,'/opt/edg/lib/perl');

}

#------------------------------------------------------------
# Application
#------------------------------------------------------------

package aii_shellfe;

use CAF::Application;
use CAF::Reporter;
use LC::Exception qw (SUCCESS throw_error);
use EDG::WP4::CCM::CacheManager;
use EDG::WP4::CDBSYNC::NCL;

use strict;
use vars qw(@ISA);

@ISA = qw(CAF::Application CAF::Reporter);


#
# Public Methods/Functions for CAF
#
sub app_options {

    push(my @array,

        { NAME    => 'configure=s',
          HELP    => 'Node(s) to be configured (can be a regexp)',
          DEFAULT => undef },

        { NAME    => 'configurelist=s',
          HELP    => 'File with the nodes to be configured',
          DEFAULT => undef },

        { NAME    => 'remove=s',
          HELP    => 'Node(s) to be removed (can be a regexp)',
          DEFAULT => undef },

        { NAME    => 'removelist=s',
          HELP    => 'File with the nodes to be removed',
          DEFAULT => undef },

        { NAME    => 'removeall',
          HELP    => 'Remove ALL nodes configured',
          DEFAULT => undef },

        { NAME    => 'boot=s',
          HELP    => 'Node(s) to boot from local disk (can be a regexp)',
          DEFAULT => undef },

        { NAME    => 'bootlist=s',
          HELP    => 'File with the nodes to boot from local disk',
          DEFAULT => undef },

        { NAME    => 'install=s',
          HELP    => 'Nodes(s) to be installed (can be regexp)',
          DEFAULT => undef },

        { NAME    => 'installlist=s',
          HELP    => 'File with the nodes to be installed',
          DEFAULT => undef },

        { NAME    => 'rescue=s',
          HELP    => 'Node(s) to be booted in rescue mode',
          DEFAULT => undef },

        { NAME    => 'rescuelist=s',
          HELP    => 'File with the nodes to be booted in rescue mode',
          DEFAULT => undef },

        { NAME    => 'notify',
          HELP    => 'Executed by CDB client whenever nodes config changed',
          DEFAULT => undef },

        { NAME    => 'status=s',
          HELP    => 'Report current boot/install status for the node ' .
                     '(can be a regexp)',
          DEFAULT => undef },

        { NAME    => 'statuslist=s',
          HELP    => 'File with the nodes to report boot/install status',
          DEFAULT => undef },

        { NAME    => 'cdburl=s',
          HELP    => 'URL for CDB location',
          DEFAULT => undef },
 
        { NAME    => 'localnclcache=s',
          HELP    => 'Local cache for NCL library',
          DEFAULT => '@QTTR_LIB@/aii/aii_ncl_cache' },

        # ccm-fetch https options

        { NAME    => 'cert_file=s',
          HELP    => 'Absolute file name for certificate file to use with HTTPS',
          DEFAULT => undef },

        { NAME    => 'key_file=s',
          HELP    => 'Absolute file name for key file to use with HTTPS',
          DEFAULT => undef },

        { NAME    => 'ca_file=s',
          HELP    => 'File containing a bundle of trusted CA certificates for use with HTTPS',
          DEFAULT => undef },

        { NAME    => 'ca_dir=s',
          HELP    => 'Directory containing trusted CA certificates for use with HTTPS. Hash symlinks are needed',
          DEFAULT => undef },


        # aii-* parameters

        { NAME    => 'nodhcp',
          HELP    => 'Do not update DHCP configuration',
          DEFAULT => undef },

        { NAME    => 'nonbp',
          HELP    => 'Do not update NBP configuration',
          DEFAULT => undef },

        { NAME    => 'noosinstall',
          HELP    => 'Do not update OS installer configuration',
          DEFAULT => undef },

        # other common options

        { NAME    => 'cfgfile=s',
          HELP    => 'configuration file for aii-shellfe defaults',
          DEFAULT => '@QTTR_ETC@/aii-shellfe.conf' },

        { NAME    => 'noaction',
          HELP    => 'do not actually perform operations',
          DEFAULT => undef },

        { NAME    => 'use_fqdn',
          HELP    => 'Use the fully qualified domain name in the profile name (if specified).',
          DEFAULT => undef },
          
        { NAME    => 'profile_prefix=s',
          HELP    => 'Default prefix for the profile name',
          DEFAULT => undef }
          
        # options inherited from CAF
        #   --help
        #   --version
        #   --verbose
        #   --debug
        #   --quiet

        );

    return(\@array);

}

sub _initialize {

    my $self = shift;

    #
    # define application specific data.
    #

    # external version number
    $self->{'VERSION'} = '1.0';

    # show setup text
    $self->{'USAGE'} = "Usage: aii-shellfe [options]\n";

    #
    # log file policies removed as fix for #6356
    #

    #
    # start initialization of CAF::Application
    #
    unless ($self->SUPER::_initialize(@_)) {
        return(undef);
    }

    return(SUCCESS);

}

#############################################################
# Main Program
#############################################################

package main;

use LC::Exception qw (SUCCESS throw_error);
use LWP::Simple;
use LWP::UserAgent;
use HTTP::Request;
use XML::Simple;
use Fcntl ':flock';  # import LOCK_* constants
use File::Path;

use strict;
use vars qw($this_app %SIG);

# initialize exception context
my $ec = LC::Exception::Context->new->will_store_errors;

#
# Global Attributes:
#

my (@NTC, @NTR, @NTB, @NTI, @NTS, @NTE);

@NTC = (); # Nodes To Configure 
@NTR = (); # Nodes To Remove
@NTB = (); # Nodes To Boot (from local disk)
@NTI = (); # Nodes To Install
@NTS = (); # Nodes To get Status
@NTE = (); # Nodes To Rescue

#
# read_cdb()
#
# get profiles from CDB
#
sub read_cdb {

    my $config;
    my ($ccmdir, $cdburl);
    my $item;
    my @NTC_aux = (); # keep track of really configurable nodes

    # part of fix for bug #15066
    my $prefix = $this_app->option('profile_prefix') || '';

    # Check URL for CDB
    $cdburl = $this_app->option('cdburl');
    if (!$cdburl) {
        $this_app->error("aii-shellfe: missing CDB's URL (use --cdburl)");
        return(1);
    }

    #
    # Get profiles for new nodes to configure
    #
    foreach $item (@NTC) {

        #
        # create a new CCM for the node
        #

        $ccmdir = "@QTTR_TMP@/aii/$item->{FQDN}";
        $config = "@QTTR_TMP@/aii/$item->{FQDN}.conf";

        if ((! -d $ccmdir) && !mkpath ($ccmdir)) {
            $this_app->error("aii-shellfe: failed to create directory: "
                             . "$ccmdir");
            next;
        }

        # create CCM conf file
        if (!open(FILE , "> $config")) {
            $this_app->error("aii-shellfe: error creating configuration file: "
                             . "$config");
            next;
        }
        print (FILE "cache_root $ccmdir\n");
        close(FILE);

        $this_app->debug(3, "aii-shellfe: fetching profile for $item->{NAME}");

        # initialize cache;
        if (system("@QTTR_SBIN@/ccm-initialise --config=$config")) {
            $this_app->error("aii-shellfe: error running: "
                             . "@QTTR_SBIN@/ccm-initialise "
                             . "--config=$config");
            next;
        }

        # fill in the cache
        # modified by Cesar Lobo (cesar.lobo@uam.es)
        #
        # fix for bug #15066
        # Make the prefix for the profile name configurable instead of 
        # assuming 'profile_'
        #        
        if (system("@QTTR_SBIN@/ccm-fetch --config=$config " 
                   . "--profile=$cdburl/$prefix$item->{NAME}.xml")) {
            $this_app->error("aii-shellfe: error running: "
                             . "@QTTR_SBIN@/ccm-fetch --config=$config "
                             . "--profile=$cdburl/$prefix$item->{NAME}.xml"); 
            next;
        }
    
        # The node is really configurable
        push(@NTC_aux, {FQDN => $item->{FQDN}, NAME=> $item->{NAME}});

    }

    # Update the @NTC array
    @NTC = @NTC_aux;

    return(0);

}

#
# update_dhcp_config()
#
# update dhcp config
#
sub update_dhcp_config() {

    my ($file_dhcp_ntc, $file_dhcp_ntr, $add_flags);
    my (%nic_list, $nic, $mac, $tftpserver, $addoptions);
    my ($nicpath, $macpath, $tftpserverpath, $addoptionspath);
    my ($cm, $cfg, $ele);
    my $item;

    $mac=undef;
    $file_dhcp_ntc = '@QTTR_TMP@/aii/dhcp_ntc.lst';
    $file_dhcp_ntr = '@QTTR_TMP@/aii/dhcp_ntr.lst';

    $nicpath        = '/hardware/cards/nic';
    $tftpserverpath = '/system/aii/dhcp/options/tftpserver';
    $addoptionspath = '/system/aii/dhcp/options/addoptions';

    $add_flags = '';

    #
    # Write list nodes to add in dhcp
    #

    if (!open(FILE, "> $file_dhcp_ntc")) {
        $this_app->error("aii-shellfe: file creation error ($file_dhcp_ntc)");
        return(1);
    }

    foreach $item (@NTC) {

        # create new CacheManager (default cache will be used)
        $cm = EDG::WP4::CCM::CacheManager->new("@QTTR_TMP@/aii/$item->{FQDN}");
        unless ($cm) {
            $this_app->error($ec->error);
            $ec->ignore_error;
            return(1);
        }       

        # get (locked) current configuration
        $cfg = $cm->getLockedConfiguration(0);
        unless ($cfg) {
            $this_app->error($ec->error);
            $ec->ignore_error;
            return(1);
        }

        # get list of NICs from profile
        if ($cfg->elementExists($nicpath)) {
            $ele = $cfg->getElement($nicpath);
            unless ($ele) {
                $this_app->error($ec->error);
                $ec->ignore_error;
                return(1);
            }
            if (!$ele->isType(EDG::WP4::CCM::Element::NLIST)) {
                $this_app->error("aii-shellfe: NIC list wrong format "
                                 . "from CDB for $item->{FQDN}");

            } else {
                %nic_list = $ele->getHash();
            }
        } else {
            $this_app->error("aii-shellfe: unable to get NIC list "
                             . "from CDB for $item->{FQDN}");
            next;
        }
    
        foreach $nic (values %nic_list) {
        
            $macpath = $nic->getPath();
            $macpath = $macpath->down('hwaddr');

            # get MAC address from profile
            if ($cfg->elementExists($macpath)) {
                next unless (($cfg->elementExists($nic->getPath()->down('boot'))) &&
                             ($cfg->getElement($nic->getPath()->down('boot'))->getValue() eq "true"));
                $mac = $cfg->getElement($macpath);
                $mac = $mac->getValue();
            } else {
                $this_app->error("aii-shellfe: unable to get MAC address "
                                 . "from CDB for $item->{FQDN}");
                next;
            }

            # get TFTP server from profile
            if ($cfg->elementExists($tftpserverpath)) {
                $tftpserver = $cfg->getElement($tftpserverpath);
                $tftpserver = $tftpserver->getValue();
            } else {
                $this_app->debug(3, "aii-shellfe: there is no TFTP server");
                $tftpserver = ' ; ';
            }

            # get options to add
            if ($cfg->elementExists($addoptionspath)) {
                $addoptions = $cfg->getElement($addoptionspath);
                $addoptions = $addoptions->getValue();
            } else {
                $this_app->debug(3, "aii-shellfe: there are no additional "
                                    . "options");
                $addoptions = ' ';
                # so we do not need this anymore
                if ($tftpserver eq ' ; ') {
                    $tftpserver = ' ';
                }
            }

            # write new record
            $this_app->debug(2, "aii-shellfe: new file entry: "
                                . "$item->{FQDN} $mac $tftpserver $addoptions");
            print FILE "$item->{FQDN} $mac $tftpserver $addoptions\n";
        }
        unless (defined $mac) {
          $this_app->error("no interface found with 'boot' field set to 'true'");
          return(1);
        }
    }


    close(FILE);

    #
    # Build list of notes to remove for dhcp
    #
    write_hosts_list($file_dhcp_ntr, @NTR);

    #
    # Execute aii-dhcp
    #
    if ($this_app->option('verbose')) {
        $add_flags = '--verbose';
    }

    $add_flags .= " --configurelist $file_dhcp_ntc "
                  . " --removelist $file_dhcp_ntr ";

    if($this_app->option('noaction')) {
        $this_app->info("aii-shellfe: run: aii-dhcp $add_flags");
    } else {
        if (system("@QTTR_SBIN@/aii-dhcp $add_flags")) {
            $this_app->warn("aii-shellfe: error executing aii-dhcp module: "
                            . "aii-dhcp $add_flags");
            return (1);
        }
    }

    #
    # Remove lists of nodes
    #
    unlink ($file_dhcp_ntc, $file_dhcp_ntr);

    return(0);

}

#
# update_nbp_config()
#
# update nbp config
#
sub update_nbp_config() {

    # temporary files with the nodelists
    my $file_nbp_nts = '@QTTR_TMP@/aii/nbp_nts.lst';
    my $file_nbp_ntc = '@QTTR_TMP@/aii/nbp_ntc.lst';
    my $file_nbp_ntr = '@QTTR_TMP@/aii/nbp_ntr.lst';
    my $file_nbp_nti = '@QTTR_TMP@/aii/nbp_nti.lst';
    my $file_nbp_ntb = '@QTTR_TMP@/aii/nbp_ntb.lst';
    my $file_nbp_nte = '@QTTR_TMP@/aii/nbp_nte.lst';
    
    my $add_flags = '';

    #
    # Build list of nodes to configure
    #
    if (write_hosts_list($file_nbp_ntc, @NTC)) {
        return (1);
    }

    #
    # Build list of nodes to get status
    #
    if (write_hosts_list($file_nbp_nts, @NTS)) {
        return (1);
    }

    #
    # Build list of nodes to remove
    #
    if (write_hosts_list($file_nbp_ntr, @NTR)) {
        return (1);
    }

    #
    # Build list of nodes to install
    #
    if (write_hosts_list($file_nbp_nti, @NTI)) {
        return (1);
    }

    #
    # Build list of nodes to boot
    #
    if (write_hosts_list($file_nbp_ntb, @NTB)) {
        return (1);
    }

    #
    # Build list of nodes to rescue
    #
    if (write_hosts_list($file_nbp_nte, @NTE)) {
        return (1);
    }


    #
    # Execute aii-nbp
    #
    if ($this_app->option('verbose')) {
        $add_flags = '--verbose';
    }
    if ($this_app->option('debug')) {
        $add_flags = ' --debug ' . $this_app->option('debug');
    }
    if ($this_app->option('removeall')) {
        $add_flags .= ' --removeall ';
    } else {
        $add_flags .= " --configurelist $file_nbp_ntc "
                      . " --removelist $file_nbp_ntr "
                      . " --installlist $file_nbp_nti "
                      . " --statuslist $file_nbp_nts "
                      . " --bootlist $file_nbp_ntb "
                      . " --rescuelist $file_nbp_nte ";
    }
   
    if($this_app->option('noaction')) {
        $this_app->info("aii-shellfe: run: aii-nbp $add_flags");
    } else {
        $this_app->debug(2, "aii-shellfe: run: aii-nbp $add_flags");
        if (system("@QTTR_SBIN@/aii-nbp $add_flags")) {
            $this_app->warn('aii-shellfe: error executing aii-nbp module');
            return(1);
        }
    }

    #
    # Remove lists of nodes
    #
    unlink ($file_nbp_ntc, $file_nbp_ntr, $file_nbp_ntb,
            $file_nbp_nti, $file_nbp_nts, $file_nbp_nte);

    return(0);

}

#
# update_osinstall_config()
#
# Update the osinstall configuration information
#
sub update_osinstall_config {

    # temporary files with the nodelists
    my $file_osinst_ntc = '@QTTR_TMP@/aii/osinst_ntc.lst';
    my $file_osinst_ntr = '@QTTR_TMP@/aii/osinst_ntr.lst';
    my $add_flags = '';

    # Build list of nodes to configure
    if (write_hosts_list($file_osinst_ntc, @NTC)) {
        $this_app->debug(2, "aii-shellfe: failed to write file with NTC: "
                            . $file_osinst_ntc);
        return (1);
    }

    # Build list of nodes to remove
    if (write_hosts_list($file_osinst_ntr, @NTR)) {
        $this_app->debug(2, "failed to write file with NTR: $file_osinst_ntc");
        return (1);
    }

    #
    # Execute aii-osinstall
    #

    if ($this_app->option('verbose')) {
        $add_flags = '--verbose';
    }
    if ($this_app->option('debug')) {
        $add_flags = ' --debug ' . $this_app->option('debug');
    }
    if ($this_app->option('removeall')) {
        $add_flags .= ' --removeall ';
    } else {
        $add_flags .= " --configurelist $file_osinst_ntc" .
                      " --removelist $file_osinst_ntr ";
    }

    if($this_app->option('noaction')) {
        $this_app->info("aii-shellfe: run: aii-osinstall $add_flags");
    } else {
        $this_app->debug(2, "aii-shellfe: running: aii-osinstall $add_flags");
        if (system("@QTTR_SBIN@/aii-osinstall $add_flags")) {
            $this_app->warn("aii-shellfe: error executing "
                            . "aii-osinstall module");
            return(1);
        }
    }

    # Remove temporary files
    unlink ($file_osinst_ntc, $file_osinst_ntr);

    return(0);

}

#
# write_host_list($filename, @hosts)
#
# write a text file with a list of FQDN hosts
# returns true in case of error
#
sub write_hosts_list {

    my $name = shift;
    my @list = @_;
    my $item;

    if (!open(FILE, "> $name")) {
        $this_app->error("aii-shellfe: error creating temporary file: $name");
        return(1);
    }

    $this_app->debug(3, "aii-shellfe: writing node list to file: $name");

    foreach $item (@list) {
        print FILE "$item->{FQDN}\n";
    }

    close(FILE);

    return(0);

}

#
# new_entry_regexp($regexp, $mode)
#
# Check and add a list of nodes to the array NTC, NTR, NTI,
# NTB, NTE or NTS. The list of nodes is given by a regular expresssion.
#
# 
sub new_entry_regexp($$) {

    my $regexp = shift;
    my $mode   = shift;

    my ($xml_url, $xml);
    my ($ua, $req, $res, $ref);
    my ($hash, $key, $found);
    
    # part of fix for bug #15066
    my $prefix = $this_app->option('profile_prefix') || '';

    $xml_url = $this_app->option('cdburl');
    if (!$xml_url) {
        $this_app->error("aii-shellfe: missing CDB's URL (use --cdburl)");
        return(1);
    }    
    $xml_url .= "/profiles-info.xml";

    $this_app->debug(3, "aii-shellfe: getting profiles list from "
                        . $xml_url);

    $ua = LWP::UserAgent->new();
    $req = HTTP::Request->new( GET => $xml_url );
    $res = $ua->request($req);

    if (!$res->is_success()) {
        $this_app->error(
            "aii-shellfe: failed to download profiles list from $xml_url: " .
            $res->message());
        return(1);
    }

    $xml = $res->content();

    if(!($ref = XMLin($xml, ForceArray => 1))) {
        $this_app->error("aii-shellfe: XML error: " . $_);
        return(1);
    }
            
    $found=0;
        
    foreach $hash (@{$ref->{profile}}) {
        $key = $$hash{"content"};
        # fix for bug #15066
        # Make the prefix for the profile name configurable instead of 
        # assuming 'profile_'
        if ($key =~ /$prefix($regexp)\.xml/) {
            new_entry($1, $mode);
            $found++;
        }
    }

    if ($found == 0) {
        $this_app->error('aii-shellfe: no matches for regexp "'
                         . $regexp . '"');
        return(1);
    }

    return(0);

}

#
# new_entry($host, $mode)
#
# Check and add a node to the array NTC, NTR, NTI, NTB ,NTS or NTE
# 
sub new_entry($$) {

    my $host = shift;
    my $mode = shift;

    my $fqdn;

    $this_app->debug(3, "aii-shellfe: new entry: \"$mode\" host \"$host\"");

    #
    # check hostname
    #

    if (!defined($host) || $host eq '') {
        $this_app->warn('aii-shellfe: missing hostname');
        return(1);
    }

    $fqdn = (gethostbyname($host))[0];
    if (!$fqdn || $fqdn eq '') {
        $this_app->warn("aii-shellfe: invalid hostname ($host) " .
                        "for operation '$mode' ");
        # this can be ok: I want to remove a node that
        # was already removed from DNS
        if ($mode ne 'remove') {
            return(1);
        }
        $fqdn = $host;
        $host =~ s/([^.]+)(.*)/$1/;
    }

    if ($this_app->option('use_fqdn')) {
        $this_app->debug(4, "aii-shellfe: use_fqdn specified, " . 
                         "keeping domain name in profile name");
    } else {
        $host = $fqdn;
        $host =~ s/([^.]+)(.*)/$1/;
    }

    $this_app->debug(4, "aii-shellfe: host \"$host\" has FQDN \"$fqdn\"");

    #
    # add the entry to the corresponding array
    #

    push(@NTI, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'install');
    push(@NTB, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'boot');
    push(@NTC, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'configure');
    push(@NTR, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'remove');
    push(@NTS, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'status');
    push(@NTE, {FQDN => $fqdn, NAME => $host})
        if ($mode eq 'rescue');

    return(0);

}

#
# get_notification()
#
# Get from CDB notification client handler
# 
sub get_notification{

    my ($not, $key, $value, $entry, %mycache);
    my (%profiles, @prof_removed);

    # read previous NCH host lists
    %mycache = ();
    if (open(FILE, '<' . $this_app->option('localnclcache')) ) {
        while ($entry = <FILE>) {
            chomp($entry);
            ($key, $value) = split(/:/,$entry);
            $mycache{$key}=$value;
        }
        close (FILE);
    }

    #
    # compare with current CDB list of hosts
    #
    
    $not = EDG::WP4::CDBSYNC::NCL->new();
    unless ($not) {
        $this_app->error($ec->error);
        $ec->ignore_error;
        return(1);
    }
    
    $this_app->debug(2, "aii-shellfe: checking for new profiles");
    %profiles = $not->getNewProfilesHash(\%mycache);
    foreach $key (keys(%profiles)) {
        $key=~s/\.xml$//;
        new_entry($key, 'configure');
        new_entry($key, 'install');
    }

    $this_app->debug(2, "aii-shellfe: checking for modified profiles");
    %profiles = $not->getModifiedProfilesHash(\%mycache);
    foreach $key (keys(%profiles)) {
        $key=~s/\.xml$//;
        new_entry($key, 'configure');
    }

    $this_app->debug(2, "aii-shellfe: checking for removed profiles");
    @prof_removed = $not->getRemovedProfilesList(\%mycache);
    foreach $key (@prof_removed) {
        $key=~s/\.xml$//;
        new_entry($key, 'remove');
    }

    # write back the current list of host
    
    %mycache = $not->getAllProfilesHash();
    if (!open(FILE, '>'.$this_app->option('localnclcache')) ) {
        $this_app->error('aii-shellfe: error updating local cache list at '
                         . $this_app->option('localnclcache'));
        return(1);
    }
    foreach $key (keys(%mycache)) {
        print FILE "$key:$mycache{$key}\n";
    }
    close (FILE);
    
    return(0);

}

#
# read_input()
#
# Read from command line and/or file lists the hostnames involved
# and save them in NTC, NTR, NTB, NTI, NTS arrays
#
# Return true in case of error
#
sub read_input {

    my ($fqdn, $host, $filename);
    my (@nodelist);
    my ($k, $item, $error);

    #
    # Read input from command line and/or file lists
    #
    for $k ('configure', 'status', 'remove', 'install', 'boot', 'rescue') {
        #
        # just one node (from command line)
        #

        if ($this_app->option($k)) {

            $host = $this_app->option($k);

            # Is it a regular expression or just a hostname?
            $fqdn = (gethostbyname($host))[0];

            if ($fqdn) {
                new_entry($host, $k);
            } else {
                $this_app->debug(2, "aii-shelfe: \"$host\" is not a valid "
                                    . "hostname, I will try as a "
                                    . "regular expression");
                new_entry_regexp($host, $k);
            }

        }

        #
        # more than one node (from a text file)
        #
        if ($this_app->option($k.'list')) {

            $filename = $this_app->option($k.'list');
            if (!open(FILE, "< $filename") ) {
                $this_app->error("aii-shellfe: $k node list error:"
                                 . " file access error: $filename");
                return(1);
            }

            $this_app->debug(2, "aii-shellfe: reading file $filename");
            @nodelist = <FILE>;
            close (FILE);

            foreach $item (@nodelist) {
                $item =~ s/[\s\n]//g; # remove spaces and \n
                if (($item ne '')  && ($item !~ /^\s*\#/)) {
                    new_entry($item, $k);
                }
            }

        }

    }

    return(0);

}

#
# lock_app()
#
# Lock application. Do not have more than one instance of
# AII tools running at the same time.
#
sub lock_app {

    my $lockfile = "@QTTR_TMP@/aii/aii.lock";

    if (!open(LOCK, "> $lockfile")) {
        $this_app->error("aii-shellfe: cannot create lockfile $lockfile");
        return(1);
    }

    if (!flock(LOCK, LOCK_EX | LOCK_NB)) {
        $this_app->info("aii-shellfe: another instance already running,"
                        . " waiting...");
    }

    flock(LOCK, LOCK_EX);

    return(0);

}

#
# unlock_app()
#
# unlock the application
#
sub unlock_app {

    flock(LOCK, LOCK_UN);

    return(0);

}

#------------------------------------------------------------
# main loop
#------------------------------------------------------------
#

# fix umask
umask (022);

# unbuffer STDOUT & STDERR
autoflush STDOUT 1;
autoflush STDERR 1;

# exit code
my $exit_code = 0;      # success
my $AII_ERR_FAILED_TO_CONFIGURE = 16;

#
# aii-shellfe expects at least one argument
# modified by Cesar Lobo (cesar.lobo@uam.es)
#
if (not scalar(@ARGV)) {
    print("[ERROR] Wrong number of arguments: Try aii-shellfe --help\n");
    exit(1);
}

#
# initialize the main class.
#
unless ($this_app = aii_shellfe->new($0, @ARGV)) {
    throw_error('aii-shellfe: cannot start application');
}

#
# Check for wrong arguments
# i.e. arguments that could not be processed
#
if (scalar(@ARGV)) {
    print("[ERROR] Wrong argument: Try aii-shellfe --help\n");
    exit(1);
}


# Create temporal directory if it does not exists already
if ((! -d "@QTTR_TMP@/aii") && !mkpath ("@QTTR_TMP@/aii")) {
    $this_app->error("aii-shellfe: failed to create directory: "
                   . "@QTTR_TMP@/aii");
    exit(1);
}

# Lock application
$this_app->debug(1, "aii-shellfe: locking application");
if (lock_app()) {
    $this_app->error("aii-shellfe: failed to lock application");
    exit(1);
}

# In case of CDB's notifications
if ($this_app->option('notify')) {
    $this_app->debug(1, "aii-shellfe: processing CDB notification");
    if(get_notification()) {
        $this_app->error("aii-shellfe: failed to process CDB notification");
        exit(1);
    }
    
}

## setup https ENV variables
my ($cert_file, $key_file, $ca_file, $ca_dir);
my $cdburl;

$cdburl = $this_app->option('cdburl');
if (!$cdburl) {
    $this_app->error("aii-shellfe: missing CDB's URL (use --cdburl)");
    exit(1);
}

if ($cdburl =~ /https:\/\//) {
    ### https in cdburl, https configvalues for ccm-fetch must be defined
    $cert_file = $this_app->option('cert_file');
    $key_file = $this_app->option('key_file');
    if (defined($key_file) and !defined($cert_file)) {
       $this_app->error("aii-shellfe: missing certificate (use --cert_file)");
       exit(1);
    } elsif (defined($cert_file) and !defined($key_file)) {
       $this_app->error("aii-shellfe: missing key (use --key_file)");
       exit(1);
    } elsif (defined($cert_file) and defined($key_file)) {
       $this_app->debug(5,"aii-shellfe: https with client authentication used");
    } else {
       $this_app->warn("aii-shellfe: missing client cert and key. https WITHOUT client authentication used.");
    }

    $ca_file = $this_app->option('ca_file');
    $ca_dir = $this_app->option('ca_dir');
    if (!defined($ca_file) && !defined($ca_dir)) {
       $this_app->warn("aii-shellfe: missing CA file or directory.  https WITHOUT server authentication used");
    }
}

$ENV{'HTTPS_CERT_FILE'} = $cert_file if (defined($cert_file));
$ENV{'HTTPS_KEY_FILE'} = $key_file if (defined($key_file));
$ENV{'HTTPS_CA_FILE'} = $ca_file if (defined($ca_file));
$ENV{'HTTPS_CA_DIR'} = $ca_dir if (defined($ca_dir));


# process command line options
$this_app->debug(1, "aii-shellfe: reading cmd line or input files");
if (read_input()) {
    $this_app->error("aii-shellfe: failed to process cmd line or input files");
    exit(1);
}

#
# Read CDB information for new nodes to configure (if any)
#
my $ntc_requested = scalar(@NTC);
if ($ntc_requested > 0) {
    $this_app->debug(1, "aii-shellfe: reading profiles from CDB ... ");
    if (read_cdb()) {
        $this_app->error("aii-shellfe: failed to access to CDB");
        exit(1);
    }
    if (scalar(@NTC) != $ntc_requested) {
        # at least one requested node was not configured
        $exit_code |= $AII_ERR_FAILED_TO_CONFIGURE;
    }
}

#
# Configure DHCP daemon, if there are NTC or NTR
#
if (scalar(@NTC) > 0 || scalar(@NTR) > 0) {

    if (!$this_app->option('nodhcp')) {
        $this_app->debug(1, "aii-shellfe: configuring DHCP ... ");
        if (update_dhcp_config()) {
            $this_app->error("aii-shellfe: failed to configure DHCP");
            exit(1);
        }
    } else {
        $this_app->verbose("aii-shellfe: skipping DHCP configuration");
    }

} else {
    $this_app->debug(1, "aii-shellfe: nothing to do with respect to DHCP");
}

#
# Configure NBP program
#
if (scalar(@NTC) > 0
           || scalar(@NTR) > 0
           || scalar(@NTB) > 0
           || scalar(@NTI) > 0
           || scalar(@NTE) > 0
           || scalar(@NTS) > 0) {

    if (!$this_app->option('nonbp')) {
        $this_app->debug(1, "aii-shellfe: configuring NBP ... ");
        if (update_nbp_config()) {
            $this_app->error("aii-shellfe: failed to configure NBP");
            exit(1);
        }
    } else {
        $this_app->verbose("aii-shellfe: skipping NBP configuration");
    }

} else {
    $this_app->debug(1, "aii-shellfe: nothing to do with respect to NBP");
}

#
# Configure OS installer
#
if (scalar(@NTC) || scalar(@NTR)) {

    if (!$this_app->option('noosinstall')) {
        $this_app->debug(1, "aii-shellfe: configuring OS installer ... ");
        if (update_osinstall_config()) {
            $this_app->error("aii-shellfe: failed to configure OS installer");
            exit(1);
        }
    } else {
        $this_app->verbose("aii-shellfe: skipping OS installer configuration");
    }

} else {
    $this_app->debug(1, "aii-shellfe: nothing to do with respect "
                        . "to OS installer");
}

#
# If we did something display a summary
# modified by Cesar Lobo (cesar.lobo@uam.es)
# 
if(scalar(@NTC) || scalar(@NTR) || scalar(@NTB) || scalar(@NTE) || scalar(@NTI)) {
    $this_app->info('aii-shellfe: changes: '
                    . scalar(@NTC) . ' added '
                    . scalar(@NTR) . ' removed '
                    . scalar(@NTB) . ' hdboot '
                    . scalar(@NTE) . ' rescue '
                    . scalar(@NTI) . ' install');
}

# UnLock application
$this_app->debug(1, "aii-shellfe: unlocking application");
if (unlock_app()) {
    $this_app->error("aii-shellfe: failed to unlock application");
    exit(1);
}
        
exit($exit_code);
